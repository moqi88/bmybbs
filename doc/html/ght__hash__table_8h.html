<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>BMY: ght_hash_table.h文件参考</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- 制作者 Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="annotated.html"><span>数据结构</span></a></li>
      <li class="current"><a href="files.html"><span>文件</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ght_hash_table.h文件参考</h1>
<p>
<div class="dynheader">
此图展示直接或间接包含该文件的文件：</div>
<div class="dynsection">
<p><center><img src="ght__hash__table_8h__dep__incl.png" border="0" usemap="#ght_hash_table.hdep_map" alt=""></center>
<map name="ght_hash_table.hdep_map">
<area shape="rect" href="crc_8h&#45;source.html" title="crc.h" alt="" coords="40,81,91,105"></map>
</div>

<p>
<a href="ght__hash__table_8h-source.html">浏览该文件的源代码。</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>数据结构</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ght_hash_entry_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ght_iterator_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a></td></tr>

<tr><td colspan="2"><br><h2>宏定义</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36c9b58f543f01d2891efe50f8f8971f"></a><!-- doxytag: member="ght_hash_table.h::GHT_HEURISTICS_NONE" ref="36c9b58f543f01d2891efe50f8f8971f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_NONE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5618d62c0493513d3c8ccf9aef2dc3d5"></a><!-- doxytag: member="ght_hash_table.h::GHT_HEURISTICS_TRANSPOSE" ref="5618d62c0493513d3c8ccf9aef2dc3d5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_TRANSPOSE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35d63817e0a10b5106b00b2dff4fb297"></a><!-- doxytag: member="ght_hash_table.h::GHT_HEURISTICS_MOVE_TO_FRONT" ref="35d63817e0a10b5106b00b2dff4fb297" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_MOVE_TO_FRONT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd8c3b9b8978d47b073c9b354d32d38b"></a><!-- doxytag: member="ght_hash_table.h::GHT_AUTOMATIC_REHASH" ref="fd8c3b9b8978d47b073c9b354d32d38b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_AUTOMATIC_REHASH</b>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8cecfc5c5c054d2875c03e77b7be15d"></a><!-- doxytag: member="ght_hash_table.h::TRUE" ref="a8cecfc5c5c054d2875c03e77b7be15d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a93f0eb578d23995850d61f7d61c55c1"></a><!-- doxytag: member="ght_hash_table.h::FALSE" ref="a93f0eb578d23995850d61f7d61c55c1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><br><h2>类型定义</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a> )(<a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td colspan="2"><br><h2>函数</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create</a> (unsigned int i_size, <a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a> fn_hash, int i_flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#dc4d38a6d414b9deed1f14baba6745f3">ght_insert</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, void *p_entry_data, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#d387f46318074aaa9022e6038a8bd995">ght_get</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#986bbd26b7afd2461d0489f185353857">ght_remove</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#7ef5668248de379e1d1c1818e1482078">ght_first</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#0a3876a4c069c754e1317d6327888074">ght_next</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#56b5a79427c6f61546a187904eb83d20">ght_rehash</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#2ed7c1800f34c9db08c25b1aea52d157">ght_finalize</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash</a> (<a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#3b82225a954364929c62ac241f417420">ght_rotating_hash</a> (<a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#9450c892d6480f6bf6ed558945a5da37">ght_crc_hash</a> (<a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *p_key)</td></tr>

</table>
<hr><a name="_details"></a><h2>详细描述</h2>
libghthash is a generic hash table used for storing arbitrary data.<p>
Libghthash really stores pointers to data - the hash table knows nothing about the actual type of the data.<p>
A simple example to get started can be found in the <code>simple.c</code> file found in the distribution. <code>hash_test.c</code> provides a more comlpete example.<p>
The MK2 version of the library should be more simple to use with fewer exported function calls and fewer structs. The usage have changed a bit since the first version though:<p>
Some basic properties of the hash table are:<p>
<ul>
<li>Both the data stored and the keys are of void type, which means that you can store any kind of data.</li></ul>
<p>
<ul>
<li>The only functions you probably will need to start is:<ul>
<li><a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create()</a>, which creates a new hash table</li><li><a class="el" href="ght__hash__table_8h.html#dc4d38a6d414b9deed1f14baba6745f3">ght_insert()</a>, which inserts a new entry into a table</li><li><a class="el" href="ght__hash__table_8h.html#d387f46318074aaa9022e6038a8bd995">ght_get()</a>, which searches for an entry</li><li><a class="el" href="ght__hash__table_8h.html#986bbd26b7afd2461d0489f185353857">ght_remove()</a>, which removes and entry.</li></ul>
</li></ul>
<p>
<ul>
<li>Inserting entries is done without first creating a key, i.e. you insert with the data, the datasize, the key and the key size directly.</li></ul>
<p>
<ul>
<li>The hash table copies the key data when inserting new entries. This means that you don't have to malloc() the key before inserting a new entry. </li></ul>
<hr><h2>类型定义文档</h2>
<a class="anchor" name="7ccccf2ebc8bef8004d3899ac5c620fa"></a><!-- doxytag: member="ght_hash_table.h::ght_fn_hash_t" ref="7ccccf2ebc8bef8004d3899ac5c620fa" args=")(ght_hash_key_t *p_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>(* <a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a>)(<a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *p_key)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Definition of the hash function pointers. ght_fn_hash_t should be used when implementing new hash functions. Look at the supplied hash functions, like <a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a>, for examples of hash functions.<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_key</em>&nbsp;</td><td>the key to calculate the hash value for.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a 32 bit hash value.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#3b82225a954364929c62ac241f417420">ght_rotating_hash()</a>, <a class="el" href="ght__hash__table_8h.html#9450c892d6480f6bf6ed558945a5da37">ght_crc_hash()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8255dcd8ac683bedac3f1623b406c4cc"></a><!-- doxytag: member="ght_hash_table.h::ght_uint32_t" ref="8255dcd8ac683bedac3f1623b406c4cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unsigned 32 bit integer. 
</div>
</div><p>
<hr><h2>函数文档</h2>
<a class="anchor" name="9450c892d6480f6bf6ed558945a5da37"></a><!-- doxytag: member="ght_hash_table.h::ght_crc_hash" ref="9450c892d6480f6bf6ed558945a5da37" args="(ght_hash_key_t *p_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a> ght_crc_hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
CRC32 hash. CRC32 hash is a good hash function. This came from Dru Lemley &lt;<a href="mailto:spambait@lemley.net">spambait@lemley.net</a>&gt;.<p>
<dl class="warning" compact><dt><b>警告:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#3b82225a954364929c62ac241f417420">ght_rotating_hash()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9f9dab962224d98f71e431d0929b5da"></a><!-- doxytag: member="ght_hash_table.h::ght_create" ref="e9f9dab962224d98f71e431d0929b5da" args="(unsigned int i_size, ght_fn_hash_t fn_hash, int i_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a>* ght_create           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a>&nbsp;</td>
          <td class="paramname"> <em>fn_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new hash table. The number of buckets should be about as big as the number of elements you wish to store in the table for good performance. The number of buckets is rounded to the next higher power of two.<p>
The possible flags are:<p>
<ul>
<li><code>GHT_HEURISTICS_TRANSPOSE</code>: Use transposing heuristics. An accessed element will move one step up in the bucket-list with this method. Cannot be combined with GHT_HEURISTICS_MOVE_TO_FRONT.</li><li><code>GHT_HEURISTICS_MOVE_TO_FRONT</code>: Use move-to-front heuristics. An accessed element will be moved the front of the bucket list with this method. Cannot be combined with GHT_HEURISTICS_TRANSPOSE.</li><li><code>GHT_AUTOMATIC_REHASH</code>: Perform automatic rehashing when the number of elements in the table are twice as many as the number of buckets. You should note that automatic rehashing will cause your application to be really slow when the table is rehashing (which might happen at times when you need speed), you should * therefore be careful with this in time-constrainted applications.</li></ul>
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i_size</em>&nbsp;</td><td>the number of buckets in the hash table. Giving a non-power of two here will round the size up to the next power of two. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn_hash</em>&nbsp;</td><td>the hash function to use (NULL for default). You can define own hash functions to use here, see the implementation of <a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a> in <code>hash_table.c</code> for an example. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_flags</em>&nbsp;</td><td>specify the flags to use. This should be bitwise or:ed. note that some options are mutually exclusive.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#3b82225a954364929c62ac241f417420">ght_rotating_hash()</a>, <a class="el" href="ght__hash__table_8h.html#9450c892d6480f6bf6ed558945a5da37">ght_crc_hash()</a></dd></dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a pointer to the hash table or NULL upon error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ed7c1800f34c9db08c25b1aea52d157"></a><!-- doxytag: member="ght_hash_table.h::ght_finalize" ref="2ed7c1800f34c9db08c25b1aea52d157" args="(ght_hash_table_t *p_ht)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ght_finalize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the hash table. <a class="el" href="ght__hash__table_8h.html#2ed7c1800f34c9db08c25b1aea52d157">ght_finalize()</a> should typically be called at the end of the program. Note that only the metadata and the keys of the table is freed, not the entries. If you want to free the entries when removing the table, the entries will have to be manually freed before <a class="el" href="ght__hash__table_8h.html#2ed7c1800f34c9db08c25b1aea52d157">ght_finalize()</a> is called like:<p>
<pre>
 ght_iterator_t iterator;
 void *p_e;</pre><p>
<pre> for(p_e = ght_first(p_table, &amp;iterator); p_e; p_e = ght_next(p_table, &amp;iterator))
   {
     free(p_e);
   }</pre><p>
<pre> ght_finalize(p_table);
 </pre><p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the table to remove. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ef5668248de379e1d1c1818e1482078"></a><!-- doxytag: member="ght_hash_table.h::ght_first" ref="7ef5668248de379e1d1c1818e1482078" args="(ght_hash_table_t *p_ht, ght_iterator_t *p_iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ght_first           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ght_iterator_t *&nbsp;</td>
          <td class="paramname"> <em>p_iterator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the first entry in the hash table. This function should be used for iteration and is used together with <a class="el" href="ght__hash__table_8h.html#0a3876a4c069c754e1317d6327888074">ght_next()</a>. Note that you cannot assume anything about the order in which the entries are accessed. If an entry is inserted during an iteration, the entry might or might not occur in the iteration.<p>
The use of the ght_iterator_t allows for several concurrent iterations, where you would use one ght_iterator_t for each iteration. In threaded environments, you should still lock access to the hash table for insertion and removal.<p>
A typical example might look as follows: <pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 ght_iterator_t iterator;
 void *p_e;</pre><p>
<pre> [Create table etc...]
 for(p_e = ght_first(p_table, &amp;iterator); p_e; p_e = ght_next(p_table, &amp;iterator))
   {
      [Do something with the current entry p_e]
   }
 </pre><p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to iterate through.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_iterator</em>&nbsp;</td><td>the iterator to use. The value of the structure is filled in by this function and may be stack allocated.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a pointer to the first entry in the table or NULL if there are no entries.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#0a3876a4c069c754e1317d6327888074">ght_next()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d387f46318074aaa9022e6038a8bd995"></a><!-- doxytag: member="ght_hash_table.h::ght_get" ref="d387f46318074aaa9022e6038a8bd995" args="(ght_hash_table_t *p_ht, unsigned int i_key_size, void *p_key_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ght_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p_key_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup an entry in the hash table. The entry is <em>not</em> removed from the table.<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to search with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to search for.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a pointer to the found entry or NULL if no entry could be found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc4d38a6d414b9deed1f14baba6745f3"></a><!-- doxytag: member="ght_hash_table.h::ght_insert" ref="dc4d38a6d414b9deed1f14baba6745f3" args="(ght_hash_table_t *p_ht, void *p_entry_data, unsigned int i_key_size, void *p_key_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ght_insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p_entry_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p_key_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an entry into the hash table. Prior to inserting anything, make sure that the table is created with <a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create()</a>. If an element with the same key as this one already exists in the table, the insertion will fail and -1 is returned.<p>
A typical example is shown below, where the string "blabla" is used as a key for the integer 15.<p>
<pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 char *p_key_data;
 int *p_data;</pre><p>
<pre> [Create p_table etc...]
 p_data = malloc(sizeof(int));
 p_key_data = "blabla";
 *p_data = 15;</pre><p>
<pre> ght_insert(p_table,
            p_data,
            sizeof(char)*strlen(p_key_data), p_key_data);
 </pre><p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to insert into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_entry_data</em>&nbsp;</td><td>the data to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to associate the data with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to use. The value will be copied, and it is therefore OK to use a stack-allocated entry here.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>0 if the element could be inserted, -1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a3876a4c069c754e1317d6327888074"></a><!-- doxytag: member="ght_hash_table.h::ght_next" ref="0a3876a4c069c754e1317d6327888074" args="(ght_hash_table_t *p_ht, ght_iterator_t *p_iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ght_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ght_iterator_t *&nbsp;</td>
          <td class="paramname"> <em>p_iterator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the next entry in the hash table. This function should be used for iteration, and must be called after <a class="el" href="ght__hash__table_8h.html#7ef5668248de379e1d1c1818e1482078">ght_first()</a>.<p>
<dl class="warning" compact><dt><b>警告:</b></dt><dd>calling this without first having called ght_first will give undefined results (probably a crash), since p_iterator isn't filled correctly.</dd></dl>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to iterate through.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_iterator</em>&nbsp;</td><td>the iterator to use.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a pointer to the next entry in the table or NULL if there are no more entries in the table.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#7ef5668248de379e1d1c1818e1482078">ght_first()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9779b2a98b420e153eb53a12c1702751"></a><!-- doxytag: member="ght_hash_table.h::ght_one_at_a_time_hash" ref="9779b2a98b420e153eb53a12c1702751" args="(ght_hash_key_t *p_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a> ght_one_at_a_time_hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One-at-a-time-hash. One-at-a-time-hash is a good hash function, and is the default when <a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create()</a> is called with NULL as the fn_hash parameter. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a><p>
<dl class="warning" compact><dt><b>警告:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#3b82225a954364929c62ac241f417420">ght_rotating_hash()</a>, <a class="el" href="ght__hash__table_8h.html#9450c892d6480f6bf6ed558945a5da37">ght_crc_hash()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="56b5a79427c6f61546a187904eb83d20"></a><!-- doxytag: member="ght_hash_table.h::ght_rehash" ref="56b5a79427c6f61546a187904eb83d20" args="(ght_hash_table_t *p_ht, unsigned int i_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ght_rehash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rehash the hash table.<p>
Rehashing will change the size of the hash table, retaining all elements. This is very costly and should be avoided unless really needed. If <code>GHT_AUTOMATIC_REHASH</code> is specified in the flag parameter when <a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create()</a> is called, the hash table is automatically rehashed when the number of stored elements exceeds two times the number of buckets in the table (making calls to this function unessessary).<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to rehash. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_size</em>&nbsp;</td><td>the new size of the table.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#e9f9dab962224d98f71e431d0929b5da">ght_create()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="986bbd26b7afd2461d0489f185353857"></a><!-- doxytag: member="ght_hash_table.h::ght_remove" ref="986bbd26b7afd2461d0489f185353857" args="(ght_hash_table_t *p_ht, unsigned int i_key_size, void *p_key_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ght_remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p_key_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an entry from the hash table. The entry is removed from the table, but not freed (that is, the data stored is not freed).<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to search with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to search for.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>a pointer to the removed entry or NULL if the entry could be found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b82225a954364929c62ac241f417420"></a><!-- doxytag: member="ght_hash_table.h::ght_rotating_hash" ref="3b82225a954364929c62ac241f417420" args="(ght_hash_key_t *p_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ght__hash__table_8h.html#8255dcd8ac683bedac3f1623b406c4cc">ght_uint32_t</a> ght_rotating_hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structght__hash__key__t.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p_key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotating hash. Not so good hash function. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a><p>
<dl class="warning" compact><dt><b>警告:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#7ccccf2ebc8bef8004d3899ac5c620fa">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#9779b2a98b420e153eb53a12c1702751">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#9450c892d6480f6bf6ed558945a5da37">ght_crc_hash()</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated at Fri Aug 29 10:29:24 2008 for BMY by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
